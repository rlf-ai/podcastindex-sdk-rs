/*
 * PodcastIndex.org API
 *
 * Download the openapi spec in [json](pi_api.json) or [yaml](pi_api.yaml) format.  # Overview  The Podcast Index (Podcast Index LLC) is a software developer focused partnership that provides tools and data to anyone who aspires to create new and exciting Podcast experiences without the heavy lifting of indexing, aggregation and data management.  # Example Code  Users have provided example code for working the API in the following languages:    - [AWS Lambda - python](https://github.com/tbowers/python-podcastindex-org-lambda)   - [Bash](https://github.com/suorcd/Bash-podcastindex-org-example)   - [C#](https://github.com/ComicStrip/csharp-podcastindex-org-example)   - [Elisp](https://github.com/sabexx/elisp-example)   - [Flutter/Dart](https://github.com/crediblecreative/flutter-dart-podcastindex-org-example)   - [Go](https://github.com/ComicStrip/Go-podcastindex-org-example)   - [Go](https://github.com/kilobit/podcast-index-client)   - [Java](https://github.com/ComicStrip/Java-podcastindex-org-example)   - [Java](https://github.com/stucoates/PodcastIndexJavaClient)   - [Node.js](https://github.com/ComicStrip/node.js-podcastindex-org-example)   - [PHP](https://github.com/Podcastindex-org/example-code)   - [Python](https://github.com/tbowers/python-podcastindex-org-example)   - [Swift](https://github.com/ComicStrip/Swift-podcastindex-org-example)   - ... [More](https://github.com/Podcastindex-org-Examples)  Don't see your desired language, create an example repo and create a [Pull Request](https://github.com/Podcastindex-org/docs-api/pulls) with a link to your example code project!  # Libraries  User created libraries for working with the API:    - Java       - [podcast4j](https://github.com/yusufyilmazfr/podcast4j)   - .NET       - [PodcastIndexSharp](https://www.nuget.org/packages/PodcastIndexSharp)   - Node.js/npm/yarn       - [podcast-index-api](https://www.npmjs.com/package/podcast-index-api)       - [podcastdx-client](https://www.npmjs.com/package/podcastdx-client)   - PHP       - [podcastindex-php](https://github.com/LowSociety/podcastindex-php)   - Python/pip       - [python-podcastindex](https://pypi.org/project/python-podcastindex/)   - R       - [podindexr](https://github.com/rpodcast/podindexr)   - Ruby       - [podcast-index](https://github.com/jasonyork/podcast-index)   - Swift       - [PodcastIndexKit](https://github.com/SparrowTek/PodcastIndexKit)   - Kotlin       - [PodcastIndex-SDK](https://github.com/mr3y-the-programmer/PodcastIndex-SDK)  Are we missing a library? Did you create one for a different language? Create a [Pull Request](https://github.com/Podcastindex-org/docs-api/pulls) with a link to the new library!  # Postman  A collection file for use in the [Postman](https://www.postman.com/) application is available for this API.    1. Download the contents of the [Postman Docs](https://github.com/Podcastindex-org/docs-api/tree/master/Postman%20Docs) folder.   2. Import the `PodcastIndex.postman_collection.json` collection to Postman   3. Import the `PodcastIndexOrgEnvironment.postman_environment.json` to Postman   4. Click \"Environments\" on the left sidebar   5. Select the checkbox next to the PodcastIndexOrgEnvironment entry   6. Set `AuthKey` and `SeceretKey` values under the \"Current Value\" column using your API information    7. Click \"Collections\" from the sidebar   8. Select PodcastIndex   9. Select and run the endpoint to test  # Contributing  The source for this API documentation is available at [https://github.com/Podcastindex-org/docs-api](https://github.com/Podcastindex-org/docs-api). Submit an Issue or create a Pull Request.  # Authentication Details  Sending an API request is easy. We use an Amazon-style request authorization token to secure each request.   Register for a free API key at https://api.podcastindex.org/   These headers parameters are required for each request: `User-Agent`, `X-Auth-Date`, `X-Auth-Key`, `Authorization`   See [Authentication](#auth) for description of parameters.  # Legal  Legal    - [Privacy Policy](https://github.com/Podcastindex-org/legal/blob/main/PrivacyPolicy.md)   - [Terms of Service](https://github.com/Podcastindex-org/legal/blob/main/TermsOfService.md)   - [License](https://github.com/Podcastindex-org/docs-api/blob/master/LICENSE)
 *
 * The version of the OpenAPI document: 1.12.1
 * Contact: info@podcastindex.org
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models, utils::auth::add_auth_headers};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`recent_slash_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentSlashDataError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recent_slash_episodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentSlashEpisodesError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recent_slash_feeds`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentSlashFeedsError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recent_slash_newfeeds`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentSlashNewfeedsError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recent_slash_newvaluefeeds`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentSlashNewvaluefeedsError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recent_slash_soundbites`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentSlashSoundbitesError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// This call returns every new feed and episode added to the index over the past 24 hours in reverse chronological order.   This is similar to `/recent/feeds` but uses the date the feed was found by the index rather than the feed's internal timestamp.   Similar data can also be accessed using object storage root url https://tracking.podcastindex.org/current   Examples:    - https://api.podcastindex.org/api/1.0/recent/data?pretty   - https://api.podcastindex.org/api/1.0/recent/data?pretty&max=10   - https://api.podcastindex.org/api/1.0/recent/data?pretty&max=10&since=1671164867
pub async fn recent_slash_data(
    configuration: &configuration::Configuration,
    max: Option<i32>,
    since: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::RecentData200Response, Error<RecentSlashDataError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recent/data", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder =
            local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<RecentSlashDataError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call returns the most recent `max` number of episodes globally across the whole index, in reverse chronological order.   Example: https://api.podcastindex.org/api/1.0/recent/episodes?max=7&pretty
pub async fn recent_slash_episodes(
    configuration: &configuration::Configuration,
    max: Option<i32>,
    exclude_string: Option<&str>,
    before: Option<i32>,
    fulltext: Option<bool>,
    pretty: Option<bool>,
) -> Result<models::RecentEpisodes200Response, Error<RecentSlashEpisodesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recent/episodes", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_string {
        local_var_req_builder =
            local_var_req_builder.query(&[("excludeString", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before {
        local_var_req_builder =
            local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fulltext {
        local_var_req_builder =
            local_var_req_builder.query(&[("fulltext", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<RecentSlashEpisodesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call returns the most recent `max` feeds, in reverse chronological order.   Examples:    - https://api.podcastindex.org/api/1.0/recent/feeds?pretty   - https://api.podcastindex.org/api/1.0/recent/feeds?max=20&cat=102,health&lang=de,ja&pretty
pub async fn recent_slash_feeds(
    configuration: &configuration::Configuration,
    max: Option<i32>,
    since: Option<i32>,
    lang: Option<&str>,
    cat: Option<&str>,
    notcat: Option<&str>,
    pretty: Option<bool>,
) -> Result<models::RecentFeeds200Response, Error<RecentSlashFeedsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recent/feeds", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder =
            local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = lang {
        local_var_req_builder =
            local_var_req_builder.query(&[("lang", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cat {
        local_var_req_builder = local_var_req_builder.query(&[("cat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = notcat {
        local_var_req_builder =
            local_var_req_builder.query(&[("notcat", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<RecentSlashFeedsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call returns every new feed added to the index over the past 24 hours in reverse chronological order.   Examples:    - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty   - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty&since=1613805000   - https://api.podcastindex.org/api/1.0/recent/newfeeds?feedid=2653471&pretty   - https://api.podcastindex.org/api/1.0/recent/newfeeds?feedid=2653471&desc&pretty
pub async fn recent_slash_newfeeds(
    configuration: &configuration::Configuration,
    max: Option<i32>,
    since: Option<i32>,
    feedid: Option<&str>,
    desc: Option<bool>,
    pretty: Option<bool>,
) -> Result<models::RecentNewfeeds200Response, Error<RecentSlashNewfeedsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recent/newfeeds", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder =
            local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = feedid {
        local_var_req_builder =
            local_var_req_builder.query(&[("feedid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = desc {
        local_var_req_builder =
            local_var_req_builder.query(&[("desc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<RecentSlashNewfeedsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call returns feeds that have added a `value` tag in reverse chronological order.   Example: https://api.podcastindex.org/api/1.0/recent/newvaluefeeds?pretty
pub async fn recent_slash_newvaluefeeds(
    configuration: &configuration::Configuration,
    max: Option<i32>,
    since: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::RecentNewvaluefeeds200Response, Error<RecentSlashNewvaluefeedsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recent/newvaluefeeds", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder =
            local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<RecentSlashNewvaluefeedsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call returns the most recent `max` soundbites that the index has discovered.   A soundbite consists of an enclosure url, a start time and a duration. It is documented in the [podcast namespace](https://github.com/Podcastindex-org/podcast-namespace/blob/main/docs/1.0.md#soundbite).   Example: https://api.podcastindex.org/api/1.0/recent/soundbites?pretty
pub async fn recent_slash_soundbites(
    configuration: &configuration::Configuration,
    max: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::RecentSoundbites200Response, Error<RecentSlashSoundbitesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/recent/soundbites", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<RecentSlashSoundbitesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
