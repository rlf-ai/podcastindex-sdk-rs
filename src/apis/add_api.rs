/*
 * PodcastIndex.org API
 *
 * Download the openapi spec in [json](pi_api.json) or [yaml](pi_api.yaml) format.  # Overview  The Podcast Index (Podcast Index LLC) is a software developer focused partnership that provides tools and data to anyone who aspires to create new and exciting Podcast experiences without the heavy lifting of indexing, aggregation and data management.  # Example Code  Users have provided example code for working the API in the following languages:    - [AWS Lambda - python](https://github.com/tbowers/python-podcastindex-org-lambda)   - [Bash](https://github.com/suorcd/Bash-podcastindex-org-example)   - [C#](https://github.com/ComicStrip/csharp-podcastindex-org-example)   - [Elisp](https://github.com/sabexx/elisp-example)   - [Flutter/Dart](https://github.com/crediblecreative/flutter-dart-podcastindex-org-example)   - [Go](https://github.com/ComicStrip/Go-podcastindex-org-example)   - [Go](https://github.com/kilobit/podcast-index-client)   - [Java](https://github.com/ComicStrip/Java-podcastindex-org-example)   - [Java](https://github.com/stucoates/PodcastIndexJavaClient)   - [Node.js](https://github.com/ComicStrip/node.js-podcastindex-org-example)   - [PHP](https://github.com/Podcastindex-org/example-code)   - [Python](https://github.com/tbowers/python-podcastindex-org-example)   - [Swift](https://github.com/ComicStrip/Swift-podcastindex-org-example)   - ... [More](https://github.com/Podcastindex-org-Examples)  Don't see your desired language, create an example repo and create a [Pull Request](https://github.com/Podcastindex-org/docs-api/pulls) with a link to your example code project!  # Libraries  User created libraries for working with the API:    - Java       - [podcast4j](https://github.com/yusufyilmazfr/podcast4j)   - .NET       - [PodcastIndexSharp](https://www.nuget.org/packages/PodcastIndexSharp)   - Node.js/npm/yarn       - [podcast-index-api](https://www.npmjs.com/package/podcast-index-api)       - [podcastdx-client](https://www.npmjs.com/package/podcastdx-client)   - PHP       - [podcastindex-php](https://github.com/LowSociety/podcastindex-php)   - Python/pip       - [python-podcastindex](https://pypi.org/project/python-podcastindex/)   - R       - [podindexr](https://github.com/rpodcast/podindexr)   - Ruby       - [podcast-index](https://github.com/jasonyork/podcast-index)   - Swift       - [PodcastIndexKit](https://github.com/SparrowTek/PodcastIndexKit)   - Kotlin       - [PodcastIndex-SDK](https://github.com/mr3y-the-programmer/PodcastIndex-SDK)  Are we missing a library? Did you create one for a different language? Create a [Pull Request](https://github.com/Podcastindex-org/docs-api/pulls) with a link to the new library!  # Postman  A collection file for use in the [Postman](https://www.postman.com/) application is available for this API.    1. Download the contents of the [Postman Docs](https://github.com/Podcastindex-org/docs-api/tree/master/Postman%20Docs) folder.   2. Import the `PodcastIndex.postman_collection.json` collection to Postman   3. Import the `PodcastIndexOrgEnvironment.postman_environment.json` to Postman   4. Click \"Environments\" on the left sidebar   5. Select the checkbox next to the PodcastIndexOrgEnvironment entry   6. Set `AuthKey` and `SeceretKey` values under the \"Current Value\" column using your API information    7. Click \"Collections\" from the sidebar   8. Select PodcastIndex   9. Select and run the endpoint to test  # Contributing  The source for this API documentation is available at [https://github.com/Podcastindex-org/docs-api](https://github.com/Podcastindex-org/docs-api). Submit an Issue or create a Pull Request.  # Authentication Details  Sending an API request is easy. We use an Amazon-style request authorization token to secure each request.   Register for a free API key at https://api.podcastindex.org/   These headers parameters are required for each request: `User-Agent`, `X-Auth-Date`, `X-Auth-Key`, `Authorization`   See [Authentication](#auth) for description of parameters.  # Legal  Legal    - [Privacy Policy](https://github.com/Podcastindex-org/legal/blob/main/PrivacyPolicy.md)   - [Terms of Service](https://github.com/Podcastindex-org/legal/blob/main/TermsOfService.md)   - [License](https://github.com/Podcastindex-org/docs-api/blob/master/LICENSE)
 *
 * The version of the OpenAPI document: 1.12.1
 * Contact: info@podcastindex.org
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models, utils::auth::add_auth_headers};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`add_slash_byfeedurl_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddSlashByfeedurlGetError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_slash_byfeedurl_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddSlashByfeedurlPostError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_slash_byitunesid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddSlashByitunesidGetError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_slash_byitunesid_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddSlashByitunesidPostError {
    Status400(models::Search400Response),
    Status401(String),
    UnknownValue(serde_json::Value),
}

/// This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.   **NOTE**: this endpoint requires an API Key with the **write** permission.   Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
pub async fn add_slash_byfeedurl_get(
    configuration: &configuration::Configuration,
    url: &str,
    chash: &str,
    itunesid: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::AddByfeedurlGet200Response, Error<AddSlashByfeedurlGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/add/byfeedurl", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("url", &url.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("chash", &chash.to_string())]);
    if let Some(ref local_var_str) = itunesid {
        local_var_req_builder =
            local_var_req_builder.query(&[("itunesid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<AddSlashByfeedurlGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.   **NOTE**: this endpoint requires an API Key with the **write** permission.   Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
pub async fn add_slash_byfeedurl_post(
    configuration: &configuration::Configuration,
    url: &str,
    itunesid: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::AddByfeedurlGet200Response, Error<AddSlashByfeedurlPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/add/byfeedurl", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("url", &url.to_string())]);
    if let Some(ref local_var_str) = itunesid {
        local_var_req_builder =
            local_var_req_builder.query(&[("itunesid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<AddSlashByfeedurlPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.   **NOTE**: this endpoint requires an API Key with the **write** permission.   Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
pub async fn add_slash_byitunesid_get(
    configuration: &configuration::Configuration,
    id: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::Search400Response, Error<AddSlashByitunesidGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/add/byitunesid", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<AddSlashByitunesidGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.   **NOTE**: this endpoint requires an API Key with the **write** permission.   Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
pub async fn add_slash_byitunesid_post(
    configuration: &configuration::Configuration,
    id: Option<i32>,
    pretty: Option<bool>,
) -> Result<models::Search400Response, Error<AddSlashByitunesidPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/add/byitunesid", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder =
            local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = add_auth_headers(local_var_req_builder, local_var_configuration).await;
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_content = local_var_resp.text().await?;
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<AddSlashByitunesidPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
